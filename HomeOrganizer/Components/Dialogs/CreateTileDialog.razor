@using HomeOrganizer.Common;
@using HomeOrganizer.Models.Features;
@using FluentValidation

<MudDialog DefaultFocus="DefaultFocus.FirstChild">
    <DialogContent>
        <MudForm Model="@model" @ref="@form" Validation="@(orderValidator.ValidateValue)" ValidationDelay="0">
            <MudCardContent>
                <MudTextField @bind-Value="model.Name"
                              For="@(() => model.Name)"
                              Immediate="true"
                              Label="Name"
                              Placeholder=@feature.TileData.UserGivenName />

                <MudTextField @bind-Value="model.Description"
                              For="@(() => model.Description)"
                              Immediate="true"
                              Label="Description"
                              Class="pt-3"
                              Lines="3"
                              Placeholder=@feature.TileData.UserGivenDescription />

            </MudCardContent>
            <MudCardContent Style="width:160px; " Class="d-flex align-center justify-center">
                <MudSelect FullWidth="false" T="string" Label="Icon" AnchorOrigin="Origin.BottomCenter" @bind-Value="model.Icon" Immediate="true" For="@(() => model.Icon)" Class="pt-3 test mx-0">
                    @foreach (var icon in icons)
                    {
                        <MudSelectItem Value="@icon">
                            <MudIcon Icon="@icon" Size="Size.Large" />
                        </MudSelectItem>
                    }
                </MudSelect>
            </MudCardContent>


        </MudForm>
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel" StartIcon="@Icons.Material.Filled.ArrowBack" Variant="Variant.Outlined" Color="Color.Warning">Cancel</MudButton>
        <MudButton Color="Color.Success" OnClick="CreateTile" EndIcon="@Icons.Material.Filled.CreateNewFolder" Variant="Variant.Outlined">Add</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] MudDialogInstance MudDialog { get; set; }
    [Parameter]
    public string FeatureName { get; set; }
    private IFeature feature;

    MudForm form;
    ModelFluentValidator orderValidator = new ModelFluentValidator();
    UserPartFeatureData model = new UserPartFeatureData();

    private class UserPartFeatureData
    {
        public string Name { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string Icon { get; set; } = MudBlazor.Icons.Material.Filled.QuestionMark;
    }

    void Submit() => MudDialog.Close(DialogResult.Ok<IFeature>(feature));
    void Cancel() => MudDialog.Cancel();

    private async Task CreateTile()
    {
        await form.Validate();
        if (!form.IsValid) return;

        feature.TileData.UserGivenName = model.Name;
        feature.TileData.UserGivenDescription = CheckDescription(model.Description);
        feature.TileData.Icon = model.Icon;
        feature.FeatureData.IsUsed = true;

        MudDialog.Close(DialogResult.Ok<IFeature>(feature));
    }

    private string CheckDescription(string description)
    {
        if (description.Length <= 30) return description;
        string newDescription = string.Empty;

        for (int i = 0; i < description.Length; i += 30)
        {
            int maxRight = i + 30;
            if (i + 30 > description.Length)
            {
                maxRight = description.Length;
            }

            string substring = description[i..maxRight];
            newDescription += substring;
            if (!substring.Contains(' '))
                newDescription += " ";
        }

        return newDescription;
    }

    protected override void OnInitialized()
    {
        feature = FeaturesList.CreateFeature(FeatureName);
        model.Icon = feature.TileData.Icon;
    }

    public static string[] icons = new string[]
    {
        MudBlazor.Icons.Material.Filled.QuestionMark,
        MudBlazor.Icons.Material.Filled.Favorite,
        MudBlazor.Icons.Material.Filled.Star,
        MudBlazor.Icons.Material.Filled.Pets,
        MudBlazor.Icons.Material.Filled.DirectionsCar,
        MudBlazor.Icons.Material.Filled.Home,
        MudBlazor.Icons.Material.Filled.Payments,
        MudBlazor.Icons.Material.Filled.TagFaces,
        MudBlazor.Icons.Material.Filled.Warning,
    };

    /// <summary>
    /// A standard AbstractValidator which contains multiple rules and can be shared with the back end API
    /// </summary>
    /// <typeparam name="UserPartFeatureData"></typeparam>
    private class ModelFluentValidator : AbstractValidator<UserPartFeatureData>
    {
        public ModelFluentValidator()
        {
            RuleFor(x => x.Name)
                .NotEmpty()
                .Length(1, 20);

            RuleFor(x => x.Description)
                .Length(0, 100);

            RuleFor(x => x.Icon)
                .NotEmpty()
                .Must(x => icons.Contains(x));
        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<UserPartFeatureData>.CreateWithOptions((UserPartFeatureData)model, x => x.IncludeProperties(propertyName)));
            if (result.IsValid)
                return Array.Empty<string>();
            return result.Errors.Select(e => e.ErrorMessage);
        };
    }
}